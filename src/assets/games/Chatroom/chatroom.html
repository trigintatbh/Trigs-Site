<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Orion Chat</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,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">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.16.0/firebase-database-compat.js"></script>
  <style>

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    background-color: #111114; /* Solid background */
    color: #ffffff;
    font-family: 'Poppins', sans-serif;
    display: flex; /* Use flexbox for centering */
    justify-content: center; /* Center horizontally */
    align-items: center; /* Center vertically */
    min-height: 100vh; /* Ensure body takes full viewport height */
    overflow: hidden; /* Hide scrollbars during auth phase */
}

h1,
h2,
p {
    margin-bottom: 12px;
}

.container {
    width: 100%;
    padding: 20px;
}

.authContainer {
    background-color: #1e1e1e;
    border-radius: 10px; /* Slightly more rounded */
    padding: 40px; /* More padding */
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.7); /* Enhanced shadow */
    max-width: 420px; /* Slightly wider */
    width: 90%; /* Responsive width */
    text-align: center;
    animation: fadeInAuth 0.3s ease-out forwards; /* Add fade-in animation */
    opacity: 0; /* Start hidden for animation */
    transform: translateY(20px); /* Start slightly lower for animation */
}

@keyframes fadeInAuth {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Button styling */
.authContainer button { /* Target buttons inside auth container */
    background-color: #7543ff; /* Primary action color */
    border: none;
    padding: 12px 25px; /* More padding */
    border-radius: 6px;
    color: #fff;
    cursor: pointer;
    font-family: 'Poppins', sans-serif;
    font-weight: 500; /* Medium weight */
    font-size: 1rem;
    width: 100%; /* Make button full width */
    margin-top: 10px; /* Space above button */
    transition: background-color 0.3s ease, transform 0.2s ease; /* Smooth transitions */
}

/* Button hover effect */
.authContainer button:hover {
    background-color: #6a35f5; /* Slightly darker on hover */
    transform: translateY(-2px); /* Slight lift on hover */
}

/* Button active effect */
.authContainer button:active {
    background-color: #5a2edb;
    transform: translateY(0); /* Press down effect */
}

p.authSwitch {
    margin-top: 25px; /* More space above the switch link */
    font-size: 0.9rem;
    color: #ccc; /* Lighter text color */
}

/* Input field styling */
input[type="text"],
input[type="password"] {
    width: 100%;
    padding: 12px 15px; /* Increased padding */
    margin-bottom: 15px; /* Space below inputs */
    border-radius: 6px; /* Slightly more rounded */
    border: 1px solid #333; /* Subtle border */
    background-color: #2a2a2e; /* Slightly lighter input background */
    color: #fff;
    font-family: 'Poppins', sans-serif;
    font-size: 1rem;
    transition: border-color 0.3s ease, box-shadow 0.3s ease; /* Smooth transitions */
}

/* Input focus effect */
input[type="text"]:focus,
input[type="password"]:focus {
    outline: none;
    border-color: #7543ff; /* Highlight border on focus */
    box-shadow: 0 0 0 3px rgba(117, 67, 255, 0.3); /* Subtle glow on focus */
}

/* Hide auth containers when main chat is shown */
body.chat-active .authContainer {
    display: none;
}
/* Show main chat when active */
body.chat-active #mainChat {
    display: flex;
}

button {
    background-color: #444;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    color: #fff;
    cursor: pointer;
    font-family: 'Poppins', sans-serif;
}

button:hover {
    background-color: #666;
}

a {
    color: #7543ff;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

p.authSwitch {
    margin-top: 15px;
}

#roomSidebar {
    width: 250px;
    background-color: #1e1e1e;
    padding: 10px;
    display: flex;
    flex-direction: column;
}

#roomList {
    flex-grow: 1;
    overflow-y: auto;
}

.roomItem {
    padding: 10px;
    cursor: pointer;
    border-bottom: 1px solid #333;
}

.roomItem:hover {
    background-color: #292929;
}

#addRoomButton {
    background-color: #444;
    border: none;
    color: #fff;
    padding: 10px;
    margin-top: 10px;
    cursor: pointer;
    border-radius: 4px;
}

#profileCard {
    display: flex;
    align-items: center;
    padding: 10px;
    border-top: 1px solid #333;
    margin-top: 10px;
    justify-content: flex-start; /* Align items to the start */
    gap: 10px; /* Add gap between items */
}

#profileCard img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
    cursor: pointer;
    object-fit: cover;
}

#profileCard span {
    cursor: pointer;
}

#chatHeader {
    position: relative;
    padding: 10px 0;
    text-align: center;
    border-bottom: 1px solid #333;
    margin-bottom: 10px;
}

#roomTitle {
    font-size: 1.2rem;
    display: inline-flex;
    align-items: center;
    margin-left: 10px;
    margin: 0 auto;
}

#roomOwnerControls {
    position: absolute;
    left: 10px;
    top: 50%;
    transform: translateY(-50%);
}

#roomOwnerControls button {
    background: none;
    border: none;
    color: #fff;
    font-size: 18px;
    cursor: pointer;
    margin-right: 10px;
}

#logoutButton {
    position: absolute;
    right: 220px;
    top: 50%;
    transform: translateY(-50%);
    background-color: #1b1b1b;
    border: none;
    padding: 8px 16px;
    color: #fff;
    border-radius: 8px;
    cursor: pointer;
}

#logoutButton:hover {
    background-color: #262626;
}

.message {
    margin-bottom: 12px;
    line-height: 1.4;
    padding: 8px;
    border-radius: 8px;
    background-color: #272727;
    word-wrap: break-word;
    overflow-wrap: break-word;
    display: flex;
    align-items: flex-start;
    animation: fadeIn 0.5s ease forwards; /* Apply fade-in animation */
    position: relative; /* Needed for reply icon positioning */
    padding-right: 35px; /* Make space for reply icon */
}

.messageHeader {
    margin-bottom: 5px;
}

.messageHeader .timestamp {
    font-size: 0.8rem;
    color: #ccc;
    margin-left: 10px;
}

#messageArea {
    max-width: calc(100% - 220px);
    overflow-x: auto;
    display: inline-block;
}

.messageContent {
    max-width: 95%;
    word-wrap: break-word;
    display: inline-block;
    flex-shrink: 0;
}

#messageInput {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1px solid #333;
    background-color: #1e1e1e;
    color: #fff;
    max-width: 99.5%;
    resize: none;
    overflow-y: hidden;
    max-height: 200px;
    box-sizing: border-box;
    word-wrap: break-word;
}

#userList {
    width: 200px;
    background-color: #1e1e1e;
    border: 1px solid #333;
    border-radius: 8px;
    margin-left: 10px;
    padding: 10px;
    overflow-y: auto;
    position: absolute;
    top: 10px;
    right: 10px;
    height: calc(100% - 20px);
    display: block;
}

#userList h3 {
    color: #fff;
    margin-bottom: 10px;
}

.member {
    display: flex;
    align-items: center;
    margin-bottom: 5px;
    color: #fff;
}

.memberPFP {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    margin-right: 8px;
    object-fit: cover;
}

.member span {
    font-size: 14px;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.4);
}

.modal-content {
    background-color: #333;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #ffffff18;
    width: 400px;
    height: 200px;
    border-radius: 10px;
    text-align: center;
    position: relative;
    align-items: center;
    align-self: center;
}

.modal-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    justify-content: center;
    align-self: center;
    align-items: center;
}

.modal-button {
    background-color: #444;
    color: white;
    padding: 15px 30px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 5px;
    width: 150px;
    height: 150px;
}

.modal-button:hover {
    background-color: #555;
}

.modal-button i {
    font-size: 20px;
}

.close {
    position: absolute;
    top: 10px;
    right: 20px;
    font-size: 24px;
    cursor: pointer;
}

.messagePFP {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 10px;
    margin-left: 5px;
    flex-shrink: 0;
    object-fit: cover;
}

.messageImages {
    margin-top: 10px;
}

#imagePreview img {
    border-radius: 5px;
}

#imagePreview div {
    position: relative;
    display: inline-block;
}

#imagePreview button {
    position: absolute;
    top: 8px;
    right: 8px;
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    font-size: 16px;
    padding: 0;
    line-height: 1;
    margin: 3px;
}

#imagePreview {
    display: flex;
    flex-wrap: wrap;
    justify-content: left;
}

.messageImages img {
    border-radius: 5px;
}

#messages::-webkit-scrollbar {
    width: 8px;
}

#messages::-webkit-scrollbar-track {
    background: transparent;
}

#messages::-webkit-scrollbar-thumb {
    background-color: white;
    border-radius: 10px;
}

#uploadMenu {
    position: absolute;
    background-color: #282828; /* Dark background */
    border: 1px solid #444; /* Dark border */
    border-radius: 5px;
    padding: 5px;
    z-index: 1001; /* Ensure it's above other elements */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5); /* Shadow for depth */
    height: 70px;
    width: 120px;
}

#uploadMenu button {
    background: none;
    border: none;
    color: #fff; /* White text */
    padding: 8px 15px;
    cursor: pointer;
    display: block;
    width: 100%;
    text-align: left;
    border-radius: 3px;
}

#uploadMenu button:hover {
    background-color: #383838; /* Slightly lighter background on hover */
}

#uploadMenu button i {
    margin-right: 8px;
}

.unreadNotifier {
    display: inline-block;
    background-color: white;
    color: #333;
    border-radius: 50%;
    padding: 5px;
    min-width: 28px;
    max-width: 28px;
    text-align: center;
    margin-left: 5px;
    font-size: 0.8em;
    position: relative;
}

.unreadNotifier::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background-color: white;
    z-index: -1;
}

.unreadNotifier.mentioned {
    background-color: red;
    color: white;
}

.input-with-icon {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.input-with-icon i {
    margin-right: 5px;
}

.icon-button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 16px;
    padding: 0;
    margin-left: 5px;
}

.create-button {
    width: calc(100% - 20px);
    padding: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 40px;
    font-size: 14px;
}

.create-button i {
    margin-right: 5px;
}

.modal-back-button {
    margin-top: 5px;
}

.file-attachment {
    border: 1px solid #555;
    padding-left: 24px;
    padding-right: 24px;
    padding-top: 16px;
    padding-bottom: 16px;
    margin: 5px 0;
    border-radius: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #444;
    width: 350px;
}

.file-attachment i.fa-file {
    margin-right: 5px;
    color: #ffffff;
}

.file-attachment a.download-icon {
    margin-left: 10px;
    color: #ffffff;
    text-decoration: none;
}

.file-attachment a.download-icon i.fa-arrow-down {
    font-size: 1.2em;
}

#mainChat {
    display: none; /* Start hidden */
    flex-direction: row; /* Ensure sidebar and chat area are side-by-side */
    width: 100vw; /* Full viewport width */
    height: 100vh; /* Full viewport height */
    overflow: hidden; /* Prevent body scroll */
}

#chatArea {
    display: flex;
    flex-grow: 1;
    padding: 10px;
}

#chatMain {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    position: relative;
    width: calc(100vw - 250px);
}

#messages {
    flex-grow: 1;
    background-color: #1e1e1e;
    border: 1px solid #333;
    border-radius: 8px;
    overflow-y: auto;
    padding: 15px;
    margin-bottom: 10px;
    width: calc(100% - 220px);
}

#inputArea {
  display: flex;
  gap: 10px;
  max-width: 87%;
  padding: 5px; /* Add some padding */
     align-items: flex-end; /* Align items to the bottom */
     max-width: calc(100% - 230px); /* Adjusted max-width considering user list */
}

  #inputArea > div {
  display: flex;
  flex-direction: column;
  flex-grow: 1;
}

.loader {
    border: 8px solid transparent; /* Light grey */
    border-top: 8px solid #ffffff; /* Blue */
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.message-context-menu {
    position: fixed;
    display: none;
    background: #111114;
    border: 1px solid #333;
    padding: 5px;
    z-index: 10000;
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

.context-menu-item {
    padding: 5px;
    cursor: pointer;
    color: #fff;
}

.image-option {
    display: none; /* Initially hidden */
}

.delete-option {
    color: #FF0000;
}

.context-menu-item:hover {
    background-color: #222; /* Add hover effect */
}

#roomContextMenu {
    position: absolute;
    display: none;
    background: #111114;
    border: 1px solid #333;
    padding: 5px;
    z-index: 10001; /* Higher z-index to ensure it's on top */
    border-radius: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    min-width: 120px; /* Adjust as needed */
}

#roomContextMenu button {
    background: none;
    border: none;
    color: #fff;
    padding: 8px 10px;
    cursor: pointer;
    display: block;
    width: 100%;
    text-align: left;
}

#roomContextMenu button:hover {
    background-color: #222;
}

#roomContextMenu button#deleteRoomButton {
    color: #FF0000;
}

.owner-icon,
.admin-icon {
    color: white;
    padding: 5px;
}

.messageText {
    word-wrap: break-word;
}

#roomList::-webkit-scrollbar {
    width: 8px;
}

#roomList::-webkit-scrollbar-track {
    background: transparent;
}

#roomList::-webkit-scrollbar-thumb {
    background-color: white;
    border-radius: 10px;
}

.edited-tag {
    font-size: smaller;
    color: gray;
    cursor: pointer;
}

.edit-textarea {
    width: 100%;
    box-sizing: border-box;
    font-family: inherit;
    font-size: inherit;
    border: 1px solid #333;
    background-color: #1e1e1e;
    border-radius: 8px;
    padding: 10px; /* Match messageInput padding */
    resize: none;
    max-width: 99.5%; /* Match messageInput max-width */
    max-height: 200px; /* Match messageInput max-height */
    overflow-y: hidden; /* Match messageInput overflow */
}

/* Add transitions for smoother hover effects */
button, .roomItem, .modal-button, .context-menu-item, #roomContextMenu button {
     transition: background-color 0.3s ease, color 0.3s ease; /* Added transition */
 }

 /* Add fade-in animation for new messages */
 @keyframes fadeIn {
     from { opacity: 0; transform: translateY(10px); }
     to { opacity: 1; transform: translateY(0); }
 }
  </style>
</head>
<body>
    <div id="loading-screen" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #111114; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999;">
        <div class="loader"></div>
        <div id="loading-message" style="margin-top: 20px; font-size: 16px; color: #ffffff;"></div>
    </div>

  <div class="container authContainer" id="loginContainer">
    <h1>Orion</h1>
    <p>Enter your username and password to login:</p>
    <input type="text" id="loginUsernameInput" placeholder="Username" />
    <input type="password" id="loginPasswordInput" placeholder="Password" />
    <button id="loginButton" onclick="login()">Login</button>
    <p class="authSwitch">Need an account? <a href="#" onclick="showRegister()">Register</a></p>
  </div>

  <div class="container authContainer" id="registerContainer" style="display: none;">
    <h1>Orion</h1>
    <p>Enter your username and password to register:</p>
    <input type="text" id="registerUsernameInput" placeholder="Username" />
    <input type="password" id="registerPasswordInput" placeholder="Password" />
    <button id="registerButton" onclick="register()">Register</button>
    <p class="authSwitch">Already have an account? <a href="#" onclick="showLogin()">Login</a></p>
  </div>

  <div id="mainChat">
    <div id="roomSidebar">
      <div id="roomList">
      </div>
      <button id="addRoomButton" onclick="openRoomModal()">+</button>
      <div id="profileCard">
        <img id="profilePicture" alt="Profile Picture">
        <span id="profileUsername"></span>
        <div id="profileIcons"></div>
      </div>
      <input type="file" id="profilePicInput" accept="image/*" style="display:none;">
    </div>
    <div id="chatArea">
      <div id="chatMain">
        <div id="chatHeader">
          <div id="roomOwnerControls" style="display:none;">
            <button id="renameGroupButton" title="Rename Group"><i class="fas fa-edit"></i></button>
            <span id="privateControls" style="display:none;">
              <button id="copyCodeButton" title="Copy Code"><i class="fas fa-copy"></i></button>
              <button id="changeCodeButton" title="Change Code"><i class="fas fa-sync-alt"></i></button>
            </span>
          </div>
          <h2 id="roomTitle">
          </h2>
          <button id="logoutButton" onclick="logout()">Logout</button>
        </div>
        <div id="messages"></div>
        <div id="inputArea">
          <div>
              <div id="imagePreview" style="display: flex; flex-wrap: wrap;"></div>
              <textarea id="messageInput" rows="1" cols="50" placeholder="Type your message here..." style="resize: none; font-family: 'Poppins', sans-serif;"></textarea>
              <div id="mentionsDisplay" style="display: none;"></div> 
          </div>
          <button id="emojiButton" style="background: none; border: none; cursor: pointer; color: #fff;">
              <i class="far fa-smile"></i>
          </button>
          <div id="uploadMenu" style="display: none; position: absolute; bottom: 60px; right: 40px; background-color: #222; padding: 5px; border-radius: 5px; z-index: 10;">
            <button id="fileUploadOption" style="background: none; border: none; cursor: pointer; color: #fff; padding: 5px;">
                <i class="fas fa-file"></i> File
            </button>
            <button id="cameraUploadOption" style="background: none; border: none; cursor: pointer; color: #fff; padding: 5px;">
                <i class="fas fa-camera"></i> Camera
            </button>
        </div>
        <button id="uploadButton" style="background: none; border: none; cursor: pointer; color: #fff; position: relative;">
            <i class="fas fa-plus"></i>
        </button>
          <button id="sendButton" style="background: none; border: none; cursor: pointer; color: #fff;">
              <i class="fas fa-paper-plane"></i>
          </button>
          <input type="file" id="fileInput" style="display: none;" multiple />
      </div>
      <script type="module" src="https://cdn.jsdelivr.net/npm/emoji-picker-element@^1/index.js"></script>
      <emoji-picker id="emojiPicker" style="display: none; position: absolute; bottom: 60px; left: 0;"></emoji-picker>
      </div>
      <div id="userList">
      </div>
    </div>
  </div>

  <div id="roomModal" class="modal" style="display:none;">
    <div class="modal-content">
      <!-- <span class="close" onclick="closeRoomModal()">&times;</span> -->
      <div id="modalContent">
        <div id="modalInitial">
          <span class="close" onclick="closeRoomModal()">&times;</span>
            <div class="modal-buttons">
                <button id="createRoomButton" class="modal-button" onclick="showRoomMakeJoin('make')">
                    <i class="fa-solid fa-hammer"></i>
                    Create
                </button>
                <button id="joinRoomButton" class="modal-button" onclick="showRoomMakeJoin('join')">
                    <i class="fa-solid fa-right-to-bracket"></i>
                    Join
                </button>
            </div>
        </div>
        </div>
        <div id="modalMake" style="display:none;">
          <div class="modal-buttons">
              <button id="createPublicRoomButton" class="modal-button" onclick="showRoomType('public')">
                  <i class="fa-solid fa-globe"></i>
                  Public
              </button>
              <button id="createPrivateRoomButton" class="modal-button" onclick="showRoomType('private')">
                  <i class="fa-solid fa-lock"></i>
                  Private
              </button>
          </div>
          <span class="close" onclick="backToInitial()">&times;</span>
          <!-- <button onclick="backToInitial()" class="modal-back-button">Back</button> -->
      </div>
      <div id="modalPublic" style="display:none;">
        <div class="input-with-icon">
            <i class="fa-solid fa-pen"></i>
            <input type="text" id="publicRoomName" placeholder="Room Name" />
        </div>
        <button onclick="createRoom('public')" class="modal-button create-button">
            <span>
                <i class="fa-solid fa-check"></i>
                Create
            </span>
        </button>
        <span class="close" onclick="backToMake()">&times;</span>
        <!-- <button onclick="backToMake()" class="modal-back-button">Back</button> -->
    </div>

    <div id="modalPrivate" style="display:none;">
        <div class="input-with-icon">
            <i class="fa-solid fa-pen"></i>
            <input type="text" id="privateRoomName" placeholder="Room Name" />
        </div>
        <div class="input-with-icon">
            <i class="fa-solid fa-key"></i>
            <input type="text" id="privateRoomCode" placeholder="Room Code" maxlength="6" value="[Initial Random Code]" oninput="this.value = this.value.toUpperCase();" />
            <button onclick="randomizeCode()" class="icon-button"><i class="fa-solid fa-dice-five"></i></button>
            <button onclick="copyCode()" class="icon-button"><i class="fa-solid fa-copy"></i></button>
        </div>
        <button onclick="createRoom('private')" class="modal-button create-button">
            <span>
                <i class="fa-solid fa-check"></i>
                Create
            </span>
        </button>
        <span class="close" onclick="backToMake()">&times;</span>
        <!-- <button onclick="backToMake()">Back</button> -->
    </div>
    <div id="modalJoin" style="display:none;">
      <div class="input-with-icon">
          <i class="fa-solid fa-key"></i>
          <input type="text" id="joinRoomCode" placeholder="Enter Room Code" maxlength="6" oninput="this.value = this.value.toUpperCase();" />
      </div>
      <button onclick="joinRoom()" class="modal-button create-button">
          <span>
              <i class="fa-solid fa-check"></i>
              Join
          </span>
      </button>
      <span class="close" onclick="backToInitial()">&times;</span>
      <!-- <button onclick="backToInitial()" class="modal-back-button">Back</button> -->
  </div>
      </div>
    </div>
  </div>

  <div id="message-context-menu" class="message-context-menu">
    <div id="copy-message" class="context-menu-item">
        <i class="fa-solid fa-copy"></i> Copy Message
    </div>
    <div id="edit-message" class="context-menu-item">
        <i class="fa-solid fa-pen"></i> Edit Message
    </div>
    <div id="copy-image" class="context-menu-item image-option">
        <i class="fa-solid fa-clone"></i> Copy Image
    </div>
    <div id="save-image" class="context-menu-item image-option">
        <i class="fa-solid fa-download"></i> Save Image
    </div>
    <div id="open-image" class="context-menu-item image-option">
        <i class="fa-solid fa-external-link-alt"></i> Open Image in New Tab
    </div>
    <div id="delete-message" class="context-menu-item delete-option">
        <i class="fa-solid fa-trash"></i> Delete Message
    </div>
</div>
<div id="roomContextMenu">
    <button id="deleteRoomButton">
        <i class="fa-solid fa-trash"></i> Delete Room
    </button>
    <button id="leaveRoomButton">
        <i class="fa-solid fa-door-open"></i> Leave Room
    </button>
</div>
<script src="https://www.gstatic.com/firebasejs/11.8.0/firebase-storage-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
    const globalRoomId = "global";

    async function checkGlobalMessagesAndShowLoading() {
        showLoadingScreen();

        setTimeout(async () => {
            try {
                const messagesSnapshot = await db.ref(`rooms/${globalRoomId}/messages`).once('value');
                const messagesData = messagesSnapshot.val();

                if (messagesData && Object.keys(messagesData).length > 0) {
                    hideLoadingScreen();
                } else {
                    hideLoadingScreen();
                }
            } catch (error) {
                hideLoadingScreen();
            }
        }, 1000);
    }

    checkGlobalMessagesAndShowLoading();
});

    function showLoadingScreen() {
        document.getElementById("loading-screen").style.display = "flex";
        displayRandomMessage();
    }

    function hideLoadingScreen() {
        document.getElementById("loading-screen").style.display = "none";
    }

    const loadingMessages = [
    "tell trig i said hi",
    "We're still in beta!",
    "h",
    "This is a random message.",
    "Getting rid of stray pixels",
    "Cleaning up the messy code",
    "Petting the cat",
    "Opening windows and letting the air in",
    "The only reason this exists is because of school",
    "I diagnose you with finnitus. That's a name of a song I made while I was sick",
    "Pouring gasoline on the firewall",
    "Fixing the lightbulb",
    "Cleaning up ectoplasm",
    "Doing absolutely nothing",
    "ðŸ˜”",
    "Hngâ€¼",
    "Putting on chapstick",
    "Some of these messages are based upon Voicemod's messages",
    "There's actually an extra 1 second delay so you can read these messages",
    "RAHH",
    "Is it just me, or is the site loading",
    "Running a diagnostic on my existential dread",
    "Shuffling the bits and bytes",
    "Trying to remember where I left my keys",
    "Downloading more RAM",
    "Finding the 'any' key",
    "Trying to figure out if it's blue and black or white and gold",
    "Checking if the fridge is running",
    "Adding RGB for performance",
    "Turning up the music WAY too loud",
    "Raging at bedwars"
    ];

    function displayRandomMessage() {
    const randomIndex = Math.floor(Math.random() * loadingMessages.length);
    const message = loadingMessages[randomIndex];
    document.getElementById("loading-message").textContent = message;
    }

    const firebaseConfig = {
      apiKey: "AIzaSyCv0MP_8kTnvk_zseAGnb1yerkSiTOmXnY",
      authDomain: "orion-chat-d49aa.firebaseapp.com",
      databaseURL: "https://orion-chat-d49aa-default-rtdb.firebaseio.com",
      projectId: "orion-chat-d49aa",
      storageBucket: "orion-chat-d49aa.firebasestorage.app",
      messagingSenderId: "1001056028076",
      appId: "1:1001056028076:web:12a1dcc5ee222ef9cd6609",
      measurementId: "G-KB5K78TQWD"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const usersRef = db.ref("users");
    const roomsRef = db.ref("rooms");

    let currentUser = localStorage.getItem("orionUsername");

    const defaultPfp = "data:image/jpeg;base64,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"
    let currentPfp = "";

    document.getElementById("profilePicture").src = defaultPfp;

    async function hashPassword(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }
    
    function showRegister() {
      document.getElementById("loginContainer").style.display = "none";
      document.getElementById("registerContainer").style.display = "block";
    }

    function showLogin() {
      document.getElementById("registerContainer").style.display = "none";
      document.getElementById("loginContainer").style.display = "block";
    }

    let userId = "";
    async function login() {
      const username = document.getElementById("loginUsernameInput").value.trim();
      const password = document.getElementById("loginPasswordInput").value;
      if (!username || !password) { alert("Please enter both a username and password."); return; }
      const hashedPassword = await hashPassword(password);
      usersRef.orderByChild("username").equalTo(username).once("value", snapshot => {
        if (!snapshot.exists()) { alert("Username or password is incorrect."); return; }
        let userRecord;
        snapshot.forEach(child => { userRecord = child.val(); userRecord = child.val(); return true; });
        if (userRecord.password !== hashedPassword) { alert("Username or password is incorrect."); return; }
        currentUser = username;
        currentUserId = userId; 
        localStorage.setItem("orionUsername", username);
        showMainChat();
      });
    }

    async function register() {
      const username = document.getElementById("registerUsernameInput").value.trim();
      const password = document.getElementById("registerPasswordInput").value;
      if (!username || !password) { alert("Please enter both a username and password."); return; }
      const hashedPassword = await hashPassword(password);
      usersRef.orderByChild("username").equalTo(username).once("value", snapshot => {
        if (snapshot.exists()) { alert("Username already taken, please choose another one."); return; }
        currentUser = username;
        localStorage.setItem("orionUsername", username);
        usersRef.push({ username: username, password: hashedPassword, pfp: defaultPfp }).then(() => {getUserProfilePicture(username);});
        showMainChat();
      });
    }

    let currentUserId = ""; 

    function logout() {
      localStorage.removeItem("orionUsername");
      currentUser = null;
      currentUserId = null;
      document.getElementById("mainChat").style.display = "none";
      showLogin();
    }

    function getUserProfilePicture(usernameToFind) {
    usersRef.once('value').then((snapshot) => {
        let userFound = false;

        snapshot.forEach((childSnapshot) => {
        const userData = childSnapshot.val();

        if (userData.username === usernameToFind) {
            currentPfp = userData.pfp; 
            profilePicture.src = currentPfp;
            userFound = true; 
            return; 
        }
    });
  });
}

    let currentRoomId = "global";
    let currentRoomData = { roomName: "Global", type: "public", owner: "system" };

    roomsRef.child("global").once("value", snapshot => {
      if(!snapshot.exists()){
         roomsRef.child("global").set({
           roomName: "Global",
           type: "public",
           owner: "system",
         });
      }
    });

let unreadCounts = {}; 

function updateNotifier(roomId, count) {
    const roomItem = document.querySelector(`.roomItem[data-room-id="${roomId}"]`);
    if (roomItem) {
        const notifier = roomItem.querySelector(".unreadNotifier");
        updatePageTitle();
        if (count > 0) {
            notifier.textContent = count;
            notifier.style.display = "inline-block";
        } else {
            notifier.textContent = "";
            notifier.style.display = "none";
        }
    }
}

function updatePageTitle() {
    let totalUnread = 0;
    for (const roomId in unreadCounts) {
        totalUnread += unreadCounts[roomId];
    }

    if (totalUnread > 0) {
        document.title = `Orion Chat (${totalUnread})`;
    } else {
        document.title = "Orion Chat";
    }
}

function loadRoomList() {
    const roomListDiv = document.getElementById("roomList");
    roomsRef.on("value", snapshot => {
        roomListDiv.innerHTML = "";
        snapshot.forEach(childSnapshot => {
            const room = childSnapshot.val();
            const roomId = childSnapshot.key;
            if (room.type === "public" || (room.type === "private" && room.members && room.members[currentUser])) {
                const roomItem = document.createElement("div");
                roomItem.className = "roomItem";
                roomItem.dataset.roomId = roomId;
                let iconHtml = room.type === "private"
                    ? '<i class="fas fa-lock" style="margin-right: 5px;"></i>'
                    : '<i class="fas fa-globe" style="margin-right: 5px;"></i>';

                if (room.announcement) {
                    iconHtml = '<i class="fas fa-bullhorn" style="margin-right: 5px;"></i>';
                }

                roomItem.innerHTML = `
                    ${iconHtml} ${room.roomName}
                    <span class="unreadNotifier"></span>
                `;

                roomItem.onclick = () => switchRoom(roomId, room);
                roomListDiv.appendChild(roomItem);

                updateNotifier(roomId, unreadCounts[roomId] || 0);

                attachRoomContextMenuListeners()
            }
        });
    });
}

function switchRoom(roomId, roomData) {
    currentRoomId = roomId;
    currentRoomData = roomData;

    const roomTitleElem = document.getElementById("roomTitle");
    let iconHtml = roomData.type === "private"
        ? '<i class="fas fa-lock" style="margin-right: 5px;"></i>'
        : '<i class="fas fa-globe" style="margin-right: 5px;"></i>';

    if (roomData.announcement) {
        iconHtml = '<i class="fas fa-bullhorn" style="margin-right: 5px;"></i>';
    }

    roomTitleElem.innerHTML = iconHtml + roomData.roomName;

    loadMessages();

    if (roomData.owner === currentUser) {
        document.getElementById("roomOwnerControls").style.display = "block";
        if (roomData.type === "private") {
            document.getElementById("privateControls").style.display = "inline";
        } else {
            document.getElementById("privateControls").style.display = "none";
        }
    } else {
        document.getElementById("roomOwnerControls").style.display = "none";
    }

    const userListElement = document.getElementById("userList");

    if (userListElement) {
        userListElement.style.display = "block";
        if (roomData.type === "private") {
            loadUserList();
        } else {
            loadPublicRoomUserList();
        }
    }

    document.getElementById("messageInput").disabled = (roomData.announcement && !isAdmin);
    document.getElementById("sendButton").disabled = (roomData.announcement && !isAdmin);
    document.getElementById("uploadButton").disabled = (roomData.announcement && !isAdmin);
    document.getElementById("emojiButton").disabled = (roomData.announcement && !isAdmin);

    if (roomData.announcement && !isAdmin) {
        document.getElementById("messageInput").placeholder = "You are not allowed to send messages in this room.";
        document.getElementById("messageInput").style.cursor = "not-allowed"; 
    } else {
        document.getElementById("messageInput").placeholder = "Type your message...";
        document.getElementById("messageInput").style.cursor = "auto"; // Reset to default
    }

    if (unreadCounts[roomId]) {
        unreadCounts[roomId] = 0;
    }

    updateNotifier(roomId, 0); 
}

async function loadMessages() {
    db.ref("rooms/" + currentRoomId + "/messages").off();

    const messagesDiv = document.getElementById("messages");
    if (messagesDiv) {
        messagesDiv.innerHTML = "";
    } else {
        return;
    }

    let query = db.ref("rooms/" + currentRoomId + "/messages").orderByChild('timestamp');
    let initialLoadComplete = false;

    query.once('value').then(snapshot => {
        let messages = [];
        snapshot.forEach(childSnapshot => {
            const data = childSnapshot.val();
            const key = childSnapshot.key;
            if (data.roomId === currentRoomId) {
                let message = {
                    data: data,
                    key: key,
                    pfpUrl: defaultPfp,
                    username: null
                };
                messages.push(message);
            }
        });

        appendMessageStyling(messages, messagesDiv)

        initialLoadComplete = true;
    });

    db.ref("rooms/" + currentRoomId + "/messages").off("child_removed"); 
    db.ref("rooms/" + currentRoomId + "/messages").on("child_removed", (snapshot) => {
        switchRoom(currentRoomId, currentRoomData);
    });

    query.on('child_added', snapshot => {
        const data = snapshot.val();
        if (data.roomId === currentRoomId) {
            if (initialLoadComplete) {
                appendMessageStyling([{ data: data, key: snapshot.key, pfpUrl: defaultPfp }], messagesDiv);
            }
        } else {

            if (!unreadCounts[data.roomId]) {
                unreadCounts[data.roomId] = 0;
            }
            unreadCounts[data.roomId]++;
            updateNotifier(data.roomId, unreadCounts[data.roomId]);
        }
    });
}

async function appendMessageStyling(messages, messagesDiv) {
    for (let message of messages) {
        try {
            const userSnapshot = await db.ref("users/" + message.data.userId).once("value");
            const userData = userSnapshot.val();
            if (userData && userData.pfp) {
                message.pfpUrl = userData.pfp;
            }

            let messageUsername = "Deleted User";
            if (userData && userData.username) {
                messageUsername = userData.username;
            }
            message.messageUsername = messageUsername;

        } catch (error) {
            console.error("Error getting pfp or username", error);
        } finally {
            setInterval(() => {
                hideLoadingScreen();
            }, 1000);
        }
    }

    messages.sort((a, b) => a.data.timestamp - b.data.timestamp);

    messages.forEach(async message => {
        const data = message.data;
        const pfpUrl = message.pfpUrl;
        const messageUsername = message.messageUsername;

        const pfpElement = document.createElement("img");
        pfpElement.className = "messagePFP";
        pfpElement.src = pfpUrl;

        const ts = new Date(data.timestamp);
        const formattedTimestamp = ts.toLocaleDateString() + " " + ts.toLocaleTimeString([], {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });

        let usernameHtml = messageUsername === currentUser
            ? `<strong>${messageUsername}</strong>`
            : `<strong>${messageUsername}</strong>`;

        let iconsHtml = "";
        const memberSnapshot = await db.ref(`users/${message.data.userId}`).once("value");
        const memberData = memberSnapshot.val();

        if (memberData) {
            if (memberData.owner) {
                iconsHtml += '<i class="fa-solid fa-crown owner-icon"></i>';
            } else if (memberData.admin) {
                iconsHtml += '<i class="fa-solid fa-shield admin-icon"></i>';
            }
        }

        const messageElement = document.createElement("div");
        messageElement.className = "message";
        messageElement.dataset.key = message.key;

        let filesHtml = '';
        if (data.files && data.files.length > 0) {
            data.files.forEach(file => {
                let fileSource = file.file || file.dataURL;

                if (file && file.type && file.type.startsWith("image/")) {
                    filesHtml += `<img src="${fileSource}" style="max-width: 350px; max-height: 350px; margin: 5px; border-radius: 5px;">`;
                } else if (file && file.type && file.type.startsWith("video/")) {
                    filesHtml += `<video src="${fileSource}" controls style="max-width: 400px; margin: 5px; border-radius: 10px;"></video>`;
                } else if (file && file.name && file.size && fileSource) {
                    filesHtml += `
                        <div class="file-attachment">
                            <i class="fa-solid fa-file"></i> <span>${file.name} (${formatBytes(file.size)})</span>
                            <a href="${fileSource}" download="${file.name}" class="download-icon">
                                <i class="fa-solid fa-arrow-down"></i>
                            </a>
                        </div>
                    `;
                }
                if (messagesDiv) {
                    setTimeout(() => {
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    }, 100);
                }
            });
        }

        let messageText = data.message;
        let editedTag = "";
        if (data.edited && data.edited.timestamp) {
            const ts = new Date(data.edited.timestamp);
            const formattedTimestamp = ts.toLocaleDateString() + " " + ts.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            editedTag = ` <span class="edited-tag" title="Edited: ${formattedTimestamp}" style="cursor: pointer; display: inline;">(edited)</span>`;
        }

        messageText = marked.parse(messageText + editedTag);

        messageElement.innerHTML = `
            ${pfpElement.outerHTML}
            <div class="messageContent">
                <div class="messageHeader">
                    ${usernameHtml} ${iconsHtml}
                    <span class="timestamp">${formattedTimestamp}</span>
                </div>
                <span class="messageText" style="display: inline;">${messageText}</span>
                <div class="messageFiles">${filesHtml}</div>
            </div>
        `;

        messagesDiv.appendChild(messageElement);

        messageElement.addEventListener("contextmenu", function (event) {
            showContextMenu(event, message.key, data.userId);
        });

        const messageFilesDiv = messageElement.querySelector('.messageFiles');
        messageFilesDiv.addEventListener("contextmenu", function (event) {
            if (event.target.tagName === "IMG") {
                event.preventDefault();
                const imageUrl = event.target.src;
                showContextMenu(event, message.key, data.userId, imageUrl);
                event.stopPropagation();
            }
        });
    });
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

async function loadUserList() {
    const userListDiv = document.getElementById("userList");
    userListDiv.innerHTML = "<h3>Users</h3>";

    db.ref("rooms/" + currentRoomId + "/members").on("value", async snapshot => {
        userListDiv.innerHTML = "<h3>Users</h3>";
        if (snapshot.exists() && typeof snapshot.val() === 'object' && snapshot.val() !== null) {
            const members = snapshot.val();
            const users = [];

            for (const username in members) {
                try {
                    const usersSnapshot = await db.ref("users").orderByChild("username").equalTo(username).once("value");
                    if (usersSnapshot.exists()) {
                        usersSnapshot.forEach(userSnapshot => {
                            const userData = userSnapshot.val();
                            if (userData) {
                                userData.userId = userSnapshot.key;
                                users.push(userData);
                            }
                        });
                    }
                } catch (error) {
                    console.error("Error getting user data:", error);
                }
            }

            for (const user of users) {
                try {
                    const userSnapshot = await db.ref("users/" + user.userId).once("value");
                    const userData = userSnapshot.val();
                    if (userData) {
                        user.admin = userData.admin || false;
                        user.owner = userData.owner || false;
                    }
                } catch (error) {
                    console.error("Error fetching user roles:", error);
                }
            }

            users.sort((a, b) => a.username.localeCompare(b.username));

            users.forEach(userData => {
                createUserDiv(userData, userListDiv);
            });
        }
    });
}

async function loadPublicRoomUserList() {
    const userListDiv = document.getElementById("userList");
    if (userListDiv) {
        userListDiv.innerHTML = "<h3>Members</h3>";
        if (currentRoomId === "global") {
            db.ref("users").on("value", async snapshot => {
                userListDiv.innerHTML = "<h3>Members</h3>";
                const users = [];
                snapshot.forEach(childSnapshot => {
                    const userData = childSnapshot.val();
                    if (userData) {
                        userData.userId = childSnapshot.key;
                        users.push(userData);
                    }
                });

                for (const user of users) {
                    try {
                        const userSnapshot = await db.ref("users/" + user.userId).once("value");
                        const userData = userSnapshot.val();
                        if (userData) {
                            user.admin = userData.admin || false;
                            user.owner = userData.owner || false;
                        }
                    } catch (error) {
                        console.error("Error fetching user roles:", error);
                    }
                }

                users.sort((a, b) => a.username.localeCompare(b.username));

                users.forEach(userData => {
                    createUserDiv(userData, userListDiv);
                });
            });
        } else {
            db.ref("rooms/" + currentRoomId + "/messages").on("value", async snapshot => {
                userListDiv.innerHTML = "<h3>Members</h3>";
                let userIds = new Set();
                snapshot.forEach(childSnapshot => {
                    const messageData = childSnapshot.val();
                    if (messageData && messageData.userId) {
                        userIds.add(messageData.userId);
                    }
                });

                const users = [];
                await Promise.all(Array.from(userIds).map(async userId => {
                    try {
                        const userSnapshot = await db.ref("users/" + userId).once("value");
                        const userData = userSnapshot.val();
                        if (userData) {
                            userData.userId = userId; 
                            users.push(userData);
                        }
                        return userData;
                    } catch (error) {
                        console.error("Error getting user data:", error);
                        return null;
                    }
                }));

                for (const user of users) {
                    try {
                        const userSnapshot = await db.ref("users/" + user.userId).once("value");
                        const userData = userSnapshot.val();
                        if (userData) {
                            user.admin = userData.admin || false;
                            user.owner = userData.owner || false;
                        }
                    } catch (error) {
                        console.error("Error fetching user roles:", error);
                    }
                }

                users.sort((a, b) => a.username.localeCompare(b.username));

                users.forEach(userData => {
                    if (userData) {
                        createUserDiv(userData, userListDiv);
                    }
                });
            });
        }
    } else {
        console.error("userList element not found.");
    }
}

function createUserDiv(userData, userListDiv) {
    const userDiv = document.createElement("div");
    userDiv.className = "member";

    const pfpElement = document.createElement("img");
    pfpElement.className = "memberPFP";
    pfpElement.src = userData.pfp || defaultPfp;

    const usernameSpan = document.createElement("span");
    usernameSpan.textContent = userData.username;

    if (userData.owner) {
        const ownerIcon = document.createElement("i");
        ownerIcon.className = "fa-solid fa-crown owner-icon";
        usernameSpan.appendChild(ownerIcon);
    } else if (userData.admin) {
        const adminIcon = document.createElement("i");
        adminIcon.className = "fa-solid fa-shield admin-icon";
        usernameSpan.appendChild(adminIcon);
    }

    userDiv.appendChild(pfpElement);
    userDiv.appendChild(usernameSpan);
    userListDiv.appendChild(userDiv);
}

async function getUserIdByUsername(currentUser) {
  try {
      const snapshot = await usersRef.orderByChild("username").equalTo(currentUser).once("value");
      const users = snapshot.val();
      if (users) {
        currentUserId = Object.keys(users)[0]; 

        return currentUserId;
      } else {

        return null;
      }
    } catch (error) {

        return null;
  }
}

getUserIdByUsername(currentUser).then(() => {
  checkUserAccount();
    usersRef.orderByChild("username").equalTo(currentUser).once("value")
        .then(snapshot => {
            snapshot.forEach(childSnapshot => {
                const userData = childSnapshot.val();
                isAdmin = userData.admin || false; 
                isOwner = userData.owner || false; 
            });
        })
        .catch(error => {
            console.error("Error fetching user data:", error);
        });
});

async function sendMessage() {
    const input = document.getElementById("messageInput");
    const message = input.value.trim();
    if (message === "" && attachedFiles.length === 0) return;

    await getUserIdByUsername(currentUser);
    const timestamp = new Date().getTime();
    const formattedMessage = message.replace(/\n/g, "<br>");

    const compressedFiles = [];
    for (const file of attachedFiles) {
        let fileData = file.file; // Store the file data
        if (typeof fileData !== 'string') { // If it's not a data URL
            fileData = await blobToDataURL(fileData); // Convert to data URL
        }

        if (file.type.startsWith('image/')) {
            const blob = dataURLtoBlob(fileData); // Convert data URL to Blob
            const compressedBlob = await compressImage(blob);
            if (compressedBlob.size > 1 * 1024 * 1024) {
                alert("File '" + file.name + "' is too large after compression (over 1MB).");
                return;
            }
            const dataUrl = await blobToDataURL(compressedBlob);
            compressedFiles.push({
                name: file.name,
                file: dataUrl,
                size: compressedBlob.size,
                type: file.type
            });
        } else if (file.type.startsWith('video/')) {
            if (file.size > 5 * 1024 * 1024) {
                alert("File '" + file.name + "' is too large (over 5MB).");
                return;
            }
            compressedFiles.push({
                name: file.name,
                file: fileData, // Use the dataURL
                size: file.size,
                type: file.type
            });
        } else {
            if (file.size > 1 * 1024 * 1024) {
                alert("File '" + file.name + "' is too large (over 1MB).");
                return;
            }
            compressedFiles.push(file);
        }
    }

    db.ref("rooms/" + currentRoomId + "/messages").push({
        userId: currentUserId,
        message: formattedMessage,
        timestamp: timestamp,
        roomId: currentRoomId,
        files: compressedFiles
    }).then(() => {
        const messagesDiv = document.getElementById("messages");
        if (messagesDiv) {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        roomsRef.once("value", snapshot => {
            snapshot.forEach(childSnapshot => {
                const roomId = childSnapshot.key;
                if (roomId !== currentRoomId && childSnapshot.val().members && childSnapshot.val().members[currentUser]) {
                    updateNotifier(roomId, unreadCounts[roomId] || 0);
                }
            });
        });
    });

    input.value = "";
    attachedFiles = [];
    displayFiles();
}

function blobToDataURL(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

function dataURLtoBlob(dataURL) {
    const byteString = atob(dataURL.split(',')[1]);
    const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeString });
}

function dataURLtoBlob(dataURL) {
    const byteString = atob(dataURL.split(',')[1]);
    const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeString });
}

function openRoomModal(){
  document.getElementById("roomModal").style.display = "flex";
  showInitialModal();
}

function closeRoomModal(){
  document.getElementById("roomModal").style.display = "none";
  showInitialModal();
}

function showInitialModal(){
  document.getElementById("modalInitial").style.display = "block";
  document.getElementById("modalMake").style.display = "none";
  document.getElementById("modalPublic").style.display = "none";
  document.getElementById("modalPrivate").style.display = "none";
  document.getElementById("modalJoin").style.display = "none";
}

function backToInitial(){ 
  showInitialModal(); 
}

function showRoomMakeJoin(type){
  document.getElementById("modalInitial").style.display = "none";
  if(type === "make"){
      document.getElementById("modalMake").style.display = "block";
    } else {
      document.getElementById("modalJoin").style.display = "block";
  }
}

function backToMake(){
  document.getElementById("modalMake").style.display = "block";
  document.getElementById("modalPublic").style.display = "none";
  document.getElementById("modalPrivate").style.display = "none";
}

function showRoomType(type){
  document.getElementById("modalMake").style.display = "none";
  if(type === "public"){
      document.getElementById("modalPublic").style.display = "block";
  } else {
      document.getElementById("modalPrivate").style.display = "block";
      randomizeCode();
  }
}

function randomizeCode(){
  const code = Math.random().toString(36).substring(2,8).toUpperCase();
  document.getElementById("privateRoomCode").value = code;
}

function copyCode(){
  const codeField = document.getElementById("privateRoomCode");
  codeField.select();
  document.execCommand("copy");
}

function createRoom(roomType){
  let roomName;
  let roomCode = "";
  if(roomType === "public"){
      roomName = document.getElementById("publicRoomName").value.trim();
      if(!roomName){ alert("Please enter a room name."); return; }
  } else {
      roomName = document.getElementById("privateRoomName").value.trim();
      roomCode = document.getElementById("privateRoomCode").value.trim();
      if(!roomName || !roomCode){ alert("Please enter a room name and code."); return; }
  }
  const newRoomRef = roomsRef.push();
  newRoomRef.set({
      roomName: roomName,
      type: roomType,
      code: roomType === "private" ? roomCode : "",
      owner: currentUser
  });
  if(roomType === "private"){
      newRoomRef.child("members").child(currentUser).set(true);
  }
  closeRoomModal();
}

function joinRoom(){
  const joinCode = document.getElementById("joinRoomCode").value.trim();
  if(!joinCode){ alert("Please enter a room code."); return; }
  roomsRef.orderByChild("code").equalTo(joinCode).once("value", snapshot => {
  if(snapshot.exists()){
    snapshot.forEach(child => {
        const roomId = child.key;
        child.ref.child("members").child(currentUser).set(true);
        switchRoom(roomId, child.val());
      });
      closeRoomModal();
    }
  });
  attachRoomContextMenuListeners()
}

document.getElementById("renameGroupButton").onclick = function(){
  const newName = prompt("Enter new room name:");
  if(newName){
    db.ref("rooms/" + currentRoomId).update({ roomName: newName });
    let iconHtml = currentRoomData.type === "private" 
    ? '<i class="fas fa-lock" style="margin-right: 5px;"></i>' 
    : '<i class="fas fa-globe" style="margin-right: 5px;"></i>';
    document.getElementById("roomTitle").innerHTML = iconHtml + newName;
  }
};

document.getElementById("changeCodeButton").onclick = function(){
  if(currentRoomData.type !== "private") return;
  const newCode = Math.random().toString(36).substring(2,8).toUpperCase();
  db.ref("rooms/" + currentRoomId).update({ code: newCode });
  alert("New code: " + newCode);
};

document.getElementById("copyCodeButton").onclick = function(){
  navigator.clipboard.writeText(currentRoomData.code);
};

function loadProfileCard() {
    const profileUsername = document.getElementById("profileUsername");
    const profilePicture = document.getElementById("profilePicture");
    const profileIcons = document.getElementById("profileIcons"); 

    profileUsername.textContent = currentUser || "Guest";
    getUserProfilePicture(currentUser);
    profilePicture.src = currentPfp;

    profileIcons.innerHTML = "";

    usersRef.orderByChild("username").equalTo(currentUser).once("value", snapshot => {
        snapshot.forEach(childSnapshot => {
            const userData = childSnapshot.val();
            const isAnAdmin = userData.admin || false;
            const isAnOwner = userData.owner || false;

            if (isAnAdmin) {
                const ownerIcon = document.createElement("i");
                ownerIcon.className = "fa-solid fa-crown owner-icon";
                profileIcons.appendChild(ownerIcon);
            } else if (isAnOwner) {
                const adminIcon = document.createElement("i");
                adminIcon.className = "fa-solid fa-shield admin-icon";
                profileIcons.appendChild(adminIcon);
            }
        });
    });
}

document.getElementById("profilePicture").addEventListener("click", function() {
  document.getElementById("profilePicInput").click();
});

document.getElementById("profilePicInput").addEventListener("change", async function(e) {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const compressedBlob = await pfpCompression(file);
        const compressedDataURL = await blobToDataURL(compressedBlob);

        const profilePicture = document.getElementById("profilePicture");
        profilePicture.src = compressedDataURL;
        localStorage.setItem("orionProfilePic", compressedDataURL);

        usersRef.orderByChild("username").equalTo(currentUser).once("value", snapshot => {
            snapshot.forEach(childSnapshot => {
                const userKey = childSnapshot.key;
                usersRef.child(userKey).update({ pfp: compressedDataURL })
                    .then(() => {
                        currentPfp = compressedDataURL;
                    });
            });
        });

        profilePicture.onload = function() {
            currentPfp = compressedDataURL;
        };
    } catch (error) {
        console.error("Error compressing and uploading pfp:", error);
        alert("Error compressing or uploading profile picture. Please try again.");
    }
});

function blobToDataURL(blob) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
    });
}

function showMainChat(){
    document.getElementById("loginContainer").style.display = "none";
    document.getElementById("registerContainer").style.display = "none";
    document.getElementById("mainChat").style.display = "flex";
    loadRoomList();
    loadProfileCard();
    switchRoom("global", { roomName: "Global", type: "public", owner: "system" });
}

if(currentUser){
  showMainChat();
}

document.getElementById("sendButton").addEventListener("click", sendMessage);

let attachedImages = []; 

const emojiPicker = document.getElementById("emojiPicker");
const emojiButton = document.getElementById("emojiButton");

emojiButton.addEventListener("click", function(event) {
    emojiPicker.style.left = "calc(100vw - 820px)";
    emojiPicker.style.display = emojiPicker.style.display === "none" ? "block" : "none";
});

document.addEventListener("keydown", function (event) {
    if (event.key === "Shift") {
        emojiPicker.dataset.shiftKeyPressed = "true";
    }
});

document.addEventListener("keyup", function (event) {
    if (event.key === "Shift") {
        emojiPicker.dataset.shiftKeyPressed = "false";
    }
});

emojiPicker.addEventListener("emoji-click", event => {
    messageInput.value += event.detail.unicode;

    // Check if shift key is pressed using dataset
    if (emojiPicker.dataset.shiftKeyPressed !== "true") {
        emojiPicker.style.display = "none";
    }
});

const uploadMenu = document.getElementById("uploadMenu");
const uploadButton = document.getElementById("uploadButton");

uploadButton.addEventListener("click", function() {
    uploadMenu.style.display = uploadMenu.style.display === "none" ? "block" : "none";
});

document.getElementById("fileUploadOption").addEventListener("click", function() {
    document.getElementById("fileInput").click();
    uploadMenu.style.display = "none";
});

document.getElementById("cameraUploadOption").addEventListener("click", async () => {
    try {
        uploadMenu.style.display = "none";

        const cameraFeedPage = document.createElement('div');
        cameraFeedPage.style.position = 'fixed';
        cameraFeedPage.style.top = '0';
        cameraFeedPage.style.left = '0';
        cameraFeedPage.style.width = '100%';
        cameraFeedPage.style.height = '100%';
        cameraFeedPage.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
        cameraFeedPage.style.zIndex = '1000';
        document.body.appendChild(cameraFeedPage);

        const video = document.createElement("video");
        video.style.width = '80%';
        video.style.height = '80%';
        video.style.display = 'block';
        video.style.margin = 'auto';
        cameraFeedPage.appendChild(video);

        const captureButton = document.createElement('button');
        captureButton.style.position = 'absolute';
        captureButton.style.bottom = '20px';
        captureButton.style.left = '50%';
        captureButton.style.transform = 'translateX(-50%)';
        captureButton.style.width = '60px';
        captureButton.style.height = '60px';
        captureButton.style.borderRadius = '50%';
        captureButton.style.backgroundColor = 'white';
        cameraFeedPage.appendChild(captureButton);

        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.play();

        captureButton.addEventListener('click', () => {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            const capturedImage = document.createElement('img');
            capturedImage.src = canvas.toDataURL("image/png");
            capturedImage.style.width = '80%';
            capturedImage.style.height = '80%';
            capturedImage.style.display = 'block';
            capturedImage.style.margin = 'auto';

            video.style.display = 'none';
            captureButton.style.display = 'none';
            cameraFeedPage.appendChild(capturedImage);

            const retryButton = document.createElement('button');
            retryButton.textContent = 'Retry';
            retryButton.style.position = 'absolute';
            retryButton.style.bottom = '20px';
            retryButton.style.left = '30%';
            retryButton.style.transform = 'translateX(-50%)';
            cameraFeedPage.appendChild(retryButton);

            const okButton = document.createElement('button');
            okButton.textContent = 'OK';
            okButton.style.position = 'absolute';
            okButton.style.bottom = '20px';
            okButton.style.left = '70%';
            okButton.style.transform = 'translateX(-50%)';
            cameraFeedPage.appendChild(okButton);

            retryButton.addEventListener('click', () => {
                cameraFeedPage.remove();
                document.getElementById('cameraUploadOption').click();
            });

            okButton.addEventListener('click', () => {
                const dataURL = canvas.toDataURL("image/png");
                const byteString = atob(dataURL.split(',')[1]);
                const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
                const ab = new ArrayBuffer(byteString.length);
                const ia = new Uint8Array(ab);
                for (let i = 0; i < byteString.length; i++) {
                    ia[i] = byteString.charCodeAt(i);
                }
                const blob = new Blob([ab], { type: mimeString });

                attachedFiles.push({
                    file: dataURL,
                    type: "image/png",
                    name: "captured-image.png",
                    size: blob.size,
                });
                displayFiles();
                cameraFeedPage.remove();
            });
        });
    } catch (error) {
        console.error("Error accessing camera:", error);
    }
});

document.getElementById("fileInput").addEventListener("change", function(e) {
    const files = e.target.files;
    if (files) {
        for (const file of files) {
            const reader = new FileReader();
            reader.onload = function(event) {
                const fileData = {
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    dataURL: event.target.result,
                    file: file 
                };
                attachedFiles.push(fileData);
                displayFiles();
            };
            reader.readAsDataURL(file);
        }
        document.getElementById("fileInput").value = '';
    }
});

let attachedFiles = [];

function displayFiles() {
    const preview = document.getElementById("imagePreview");
    preview.innerHTML = "";

    if (attachedFiles) {
        attachedFiles.forEach((file, index) => {
            if (file && file.type) {
                const fileContainer = document.createElement("div");
                fileContainer.style.margin = "5px";

                const removeButton = document.createElement("button");
                removeButton.innerHTML = '<i class="fas fa-times"></i>';
                removeButton.style.display = "block";
                removeButton.addEventListener("click", function () {
                    attachedFiles.splice(index, 1);
                    displayFiles();
                });
                fileContainer.appendChild(removeButton);

                if (file.type.startsWith("image/")) {
                    const img = document.createElement("img");
                    img.src = typeof file.file === 'string' ? file.file : URL.createObjectURL(file.file); // Create object URL
                    img.style.maxWidth = "200px";
                    img.style.maxHeight = "200px";
                    fileContainer.appendChild(img);
                } else if (file.type.startsWith("video/")) {
                    const video = document.createElement("video");
                    video.src = typeof file.file === 'string' ? file.file : URL.createObjectURL(file.file); // Create object URL
                    video.controls = true;
                    video.style.maxWidth = "200px";
                    fileContainer.appendChild(video);
                } else {
                    const fileInfo = document.createElement("div");
                    fileInfo.className = "file-attachment-preview";

                    const fileName = document.createElement("span");
                    fileName.textContent = `${file.name} (${formatBytes(file.size)})`;
                    fileInfo.appendChild(fileName);

                    fileContainer.appendChild(fileInfo);
                }
                preview.appendChild(fileContainer);
            }
        });
    }
}

function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

document.getElementById("fileInput").addEventListener("change", function(e) {
    const files = e.target.files;
    if (files) {
        for (const file of files) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    attachedImages.push(event.target.result);
                    displayImages();
                };
                reader.readAsDataURL(file);
        }
        document.getElementById("fileInput").value = '';
    }
});

function displayImages() {
    const preview = document.getElementById("imagePreview");
    preview.innerHTML = "";
    attachedImages.forEach((dataURL, index) => {
        const img = document.createElement("img");
        img.src = dataURL;
        img.style.maxWidth = "200px";
        img.style.maxHeight = "200px";
        img.style.margin = "5px";
        const removeButton = document.createElement("button");
        removeButton.innerHTML = '<i class="fas fa-times"></i>'; 
        removeButton.style.display = "block";
        removeButton.addEventListener("click", function() {
            attachedImages.splice(index, 1);
            displayImages();
        });
        const imageContainer = document.createElement("div");
        imageContainer.appendChild(img);
        imageContainer.appendChild(removeButton);
        preview.appendChild(imageContainer);
    });
}

function checkUserAccount() {
    const userId = localStorage.getItem("orionUserId");
    if (currentUserId === '') {
        db.ref("users/" + userId).once("value");
    }
}

function pfpCompression(file, maxWidth = 500, quality = 0.3) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = function(event) {
            const img = new Image();
            img.onload = function() {
                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height *= maxWidth / width;
                    width = maxWidth;
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                // Check for transparency
                let hasTransparency = false;
                const imageData = ctx.getImageData(0, 0, width, height).data;
                for (let i = 3; i < imageData.length; i += 4) {
                    if (imageData[i] < 255) {
                        hasTransparency = true;
                        break;
                    }
                }

                if (hasTransparency) {
                    canvas.toBlob(blob => {
                        resolve(blob);
                    }, 'image/png');
                } else {
                    canvas.toBlob(blob => {
                        resolve(blob);
                    }, 'image/jpeg', quality);
                }
            };
            img.onerror = reject;
            img.src = event.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}

document.addEventListener('DOMContentLoaded', function() {
    const messageInput = document.getElementById('messageInput');
    if (messageInput) {
        messageInput.addEventListener('dragover', (event) => {
            event.preventDefault();
        });

        messageInput.addEventListener('drop', async (event) => {
    event.preventDefault();
    const files = event.dataTransfer.files;
    for (const file of files) {
        if (file.type.startsWith('image/')) {
            const compressedBlob = await compressImage(file);
            const dataUrl = await blobToDataURL(compressedBlob);
            attachedFiles.push({
                name: file.name,
                file: compressedBlob,
                size: compressedBlob.size,
                type: file.type,
                url: dataUrl
            });
        } else {
            attachedFiles.push({
                name: file.name,
                file: file,
                size: file.size,
                type: file.type,
                url: URL.createObjectURL(file)
            });
        }
    }
    displayFiles();
});

        messageInput.addEventListener('paste', async (event) => {
    const items = (event.clipboardData || event.originalEvent.clipboardData).items;
    for (const item of items) {
        if (item.type.indexOf('image') !== -1) {
            const blob = item.getAsFile();
            const compressedBlob = await compressImage(blob); // Compress the image
            const dataUrl = await blobToDataURL(compressedBlob); // Convert to data URL
            attachedFiles.push({
                name: 'image.png',
                file: compressedBlob, // Store the compressed blob
                size: compressedBlob.size,
                type: blob.type,
                url: dataUrl
            });
            displayFiles();
        } else if (item.kind === 'file') {
            const file = item.getAsFile();
            if (file) {
                attachedFiles.push({
                    name: file.name,
                    file: file,
                    size: file.size,
                    type: file.type,
                    url: URL.createObjectURL(file)
                });
                displayFiles();
            }
        }
    }
});
    } else {
        console.error("messageInput element not found!");
    }
});

document.getElementById("messageInput").addEventListener("keydown", function (e) {
    if (e.key === "Enter") {
        if (e.shiftKey) {
            e.preventDefault();
            this.value += "\n";
        } else {
            e.preventDefault();
            sendMessage();
        }
    }
});

async function compressImage(file, maxWidth = 800) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height *= maxWidth / width;
                    width = maxWidth;
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                const outputFormat = file.type === 'image/png' ? 'image/png' : 'image/jpeg';
                const quality = calculateQuality(maxWidth); 

                canvas.toBlob((blob) => {
                    if (blob) {
                        resolve(blob);
                    } else {
                        resolve(file);
                    }
                }, outputFormat, quality);

            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    });
}

function calculateQuality(maxWidth) {
  const baseQuality = 0.8;
    const qualityReduction = (maxWidth - 800) / 1000; 

    let quality = baseQuality - qualityReduction;

    quality = Math.max(0.1, Math.min(1, quality)); 

    return quality;
}

async function showContextMenu(event, messageId, messageOwnerId, imageUrl) {
    event.preventDefault();

    const contextMenu = document.getElementById("message-context-menu");
    const copyMessage = document.getElementById("copy-message");
    const copyImage = document.getElementById("copy-image");
    const saveImage = document.getElementById("save-image");
    const openImage = document.getElementById("open-image");
    const deleteMessageButton = document.getElementById("delete-message");
    const editMessageButton = document.getElementById("edit-message");

    copyMessage.onclick = function() {
        copyMessageToClipboard(messageId);
        contextMenu.style.display = "none";
    };

    if (imageUrl) {
        //copyImage.style.display = "block";
        saveImage.style.display = "block";
        openImage.style.display = "block";

        copyMessage.style.display = "none";

        copyImage.onclick = function() {
            copyImageToClipboard(imageUrl);
            contextMenu.style.display = "none";
        };

        saveImage.onclick = function() {
            saveImageToFile(imageUrl);
            contextMenu.style.display = "none";
        };

        openImage.onclick = function() {
            const newWindow = window.open();
            if (newWindow) {
                newWindow.document.write(`
                    <body style="background-color: black; margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh;">
                        <img src="${imageUrl}">
                    </body>
                `);
            } else {
                alert("Please allow pop-ups to open the image in a new tab.");
            }
            contextMenu.style.display = "none";
        };
    } else {
        copyImage.style.display = "none";
        saveImage.style.display = "none";
        openImage.style.display = "none";

        copyMessage.style.display = "block";
    }

    if (messageOwnerId === currentUserId) {
        editMessageButton.style.display = "block";
        editMessageButton.onclick = function() {
            editMessage(messageId);
            contextMenu.style.display = "none";
        };
    } else {
        editMessageButton.style.display = "none";
    }

    if (messageOwnerId === currentUserId || isAdmin) {
        deleteMessageButton.style.display = "block";
        deleteMessageButton.onclick = function() {
            deleteMessage(messageId);
            contextMenu.style.display = "none";
        };
    } else {
        deleteMessageButton.style.display = "none";
    }

    contextMenu.style.left = event.pageX + "px";
    contextMenu.style.top = event.pageY + "px";
    contextMenu.style.display = "block";

    document.addEventListener("click", function closeMenu(e) {
        if (!contextMenu.contains(e.target)) {
            contextMenu.style.display = "none";
            document.removeEventListener("click", closeMenu);
        }
    });
}

function hideContextMenu() {
    const contextMenu = document.getElementById("message-context-menu");
    contextMenu.style.display = "none";
}

async function copyMessageToClipboard(messageId) {
    const messageSnapshot = await db.ref(`rooms/${currentRoomId}/messages/${messageId}`).once("value");
    const messageData = messageSnapshot.val();
    if (messageData && messageData.message) {
        await navigator.clipboard.writeText(messageData.message);
        console.log("Message copied to clipboard");
    }
}

async function copyImageToClipboard(imageUrl) {
    const response = await fetch(imageUrl);
    const blob = await response.blob();
    await navigator.clipboard.write([new ClipboardItem({ [blob.type]: blob })]);
}

async function saveImageToFile(imageUrl) {
    const response = await fetch(imageUrl);
    const blob = await response.blob();
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "image.png";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

async function deleteMessage(messageId) {
    await firebase.database().ref(`rooms/${currentRoomId}/messages/${messageId}`).remove();
    switchRoom(currentRoomId, currentRoomData);
}

function showRoomContextMenu(event, roomId) {
    const contextMenu = document.getElementById("roomContextMenu");
    const deleteRoomButton = document.getElementById("deleteRoomButton");
    const leaveRoomButton = document.getElementById("leaveRoomButton");

    db.ref(`rooms/${roomId}/owner`).once("value", snapshot => {
        const roomOwnerId = snapshot.val();

        if (roomOwnerId === currentUserId || isAdmin) {
            deleteRoomButton.style.display = "block";
            deleteRoomButton.onclick = function() {
                deleteRoom(roomId);
                hideRoomContextMenu();
            };
        } else {
            deleteRoomButton.style.display = "none";
        }

        db.ref(`rooms/${roomId}/type`).once("value", snapshot => {
            const roomType = snapshot.val();

            if (roomId !== "global" && roomType !== "public") {
                leaveRoomButton.style.display = "block";
                leaveRoomButton.onclick = function() {
                    leaveRoom(roomId);
                    hideRoomContextMenu();
                };
            } else {
                leaveRoomButton.style.display = "none";
            }

            contextMenu.style.left = event.pageX + "px";
            contextMenu.style.top = event.pageY + "px";
            contextMenu.style.display = "block";

            document.addEventListener("click", function closeMenu(e) {
                if (!contextMenu.contains(e.target)) {
                    hideRoomContextMenu();
                    document.removeEventListener("click", closeMenu);
                }
            });
        });
    });
}

function hideRoomContextMenu() {
    document.getElementById("roomContextMenu").style.display = "none";
}

function deleteRoom(roomId) {
    db.ref(`rooms/${roomId}`).remove()
        .then(() => {
            db.ref("rooms/global").once("value", snapshot => {
                const globalRoomData = snapshot.val();
                if (globalRoomData) {
                    switchRoom("global", globalRoomData);
                };
            });
        });
}

function leaveRoom(roomId) {
    db.ref(`rooms/${roomId}/members/${currentUser}`).remove()
        .then(() => {
            console.log("Left room:", roomId);
            db.ref("rooms/global").once("value", snapshot => {
                const globalRoomData = snapshot.val();
                if (globalRoomData) {
                    switchRoom("global", globalRoomData);
                }
            });
            attachRoomContextMenuListeners();
        });
}

function attachRoomContextMenuListeners() {
    let roomItems = document.querySelectorAll(".roomItem");
    roomItems.forEach(roomItem => {
        roomItem.addEventListener("contextmenu", event => {
            event.preventDefault();
            event.stopPropagation();
            const roomId = roomItem.dataset.roomId;

            if (roomId !== "global") { 
                showRoomContextMenu(event, roomId);
            };
        });
    });
}

async function editMessage(messageKey) {
    const messageRef = db.ref(`rooms/${currentRoomId}/messages/${messageKey}`);
    const messageSnapshot = await messageRef.once("value");
    const messageData = messageSnapshot.val();

    if (!messageData) return;

    const messageElement = document.querySelector(`.message[data-key="${messageKey}"] .messageText`);
    if (!messageElement) return;

    const originalMessage = messageData.message;

    messageElement.innerHTML = `<textarea class="edit-textarea">${originalMessage}</textarea>`;
    const textarea = messageElement.querySelector("textarea");
    textarea.focus();

    textarea.addEventListener("keydown", async (event) => {
        if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            const newMessage = textarea.value;
            if (newMessage !== originalMessage) {
                await messageRef.update({
                    message: newMessage,
                    edited: {
                        timestamp: new Date().getTime(),
                    },
                });
            }
            loadMessages(currentRoomId);
        } else if (event.key === "Escape") {
            loadMessages(currentRoomId);
        }
    });
}
</script>
</body>
</html>